{"version":3,"file":"HydrationStreamProvider.cjs","sources":["../../src/HydrationStreamProvider.tsx"],"sourcesContent":["'use client'\n\nimport { useServerInsertedHTML } from 'next/navigation'\nimport * as React from 'react'\n\nconst serializedSymbol = Symbol('serialized')\n\ninterface DataTransformer {\n  serialize(object: any): any\n  deserialize(object: any): any\n}\n\ntype Serialized<TData> = unknown & {\n  [serializedSymbol]: TData\n}\n\ninterface TypedDataTransformer<TData> {\n  serialize: (obj: TData) => Serialized<TData>\n  deserialize: (obj: Serialized<TData>) => TData\n}\n\ninterface HydrationStreamContext<TShape> {\n  id: string\n  stream: {\n    /**\n     * **Server method**\n     * Push a new entry to the stream\n     * Will be ignored on the client\n     */\n    push: (...shape: TShape[]) => void\n  }\n}\n\nexport interface HydrationStreamProviderProps<TShape> {\n  children: React.ReactNode\n  /**\n   * Optional transformer to serialize/deserialize the data\n   * Example devalue, superjson et al\n   */\n  transformer?: DataTransformer\n  /**\n   * **Client method**\n   * Called in the browser when new entries are received\n   */\n  onEntries: (entries: TShape[]) => void\n  /**\n   * **Server method**\n   * onFlush is called on the server when the cache is flushed\n   */\n  onFlush?: () => TShape[]\n}\n\nexport function createHydrationStreamProvider<TShape>() {\n  const context = React.createContext<HydrationStreamContext<TShape>>(\n    null as any,\n  )\n  /**\n\n   * 1. (Happens on server): `useServerInsertedHTML()` is called **on the server** whenever a `Suspense`-boundary completes\n   *    - This means that we might have some new entries in the cache that needs to be flushed\n   *    - We pass these to the client by inserting a `<script>`-tag where we do `window[id].push(serializedVersionOfCache)`\n   * 2. (Happens in browser) In `useEffect()`:\n   *   - We check if `window[id]` is set to an array and call `push()` on all the entries which will call `onEntries()` with the new entries\n   *   - We replace `window[id]` with a `push()`-method that will be called whenever new entries are received\n   **/\n  function UseClientHydrationStreamProvider(props: {\n    children: React.ReactNode\n    /**\n     * Optional transformer to serialize/deserialize the data\n     * Example devalue, superjson et al\n     */\n    transformer?: DataTransformer\n    /**\n     * **Client method**\n     * Called in the browser when new entries are received\n     */\n    onEntries: (entries: TShape[]) => void\n    /**\n     * **Server method**\n     * onFlush is called on the server when the cache is flushed\n     */\n    onFlush?: () => TShape[]\n  }) {\n    // unique id for the cache provider\n    const id = `__RQ${React.useId()}`\n    const idJSON = JSON.stringify(id)\n\n    const [transformer] = React.useState(\n      () =>\n        (props.transformer ?? {\n          // noop\n          serialize: (obj: any) => obj,\n          deserialize: (obj: any) => obj,\n        }) as unknown as TypedDataTransformer<TShape>,\n    )\n\n    // <server stuff>\n    const [stream] = React.useState<TShape[]>(() => {\n      if (typeof window !== 'undefined') {\n        return {\n          push() {\n            // no-op on the client\n          },\n        } as unknown as TShape[]\n      }\n      return []\n    })\n    const count = React.useRef(0)\n    useServerInsertedHTML(() => {\n      // This only happens on the server\n      stream.push(...(props.onFlush?.() ?? []))\n\n      if (!stream.length) {\n        return null\n      }\n      // console.log(`pushing ${stream.length} entries`)\n      const serializedCacheArgs = stream\n        .map((entry) => transformer.serialize(entry))\n        .map((entry) => JSON.stringify(entry))\n        .join(',')\n\n      // Flush stream\n      stream.length = 0\n\n      const html: string[] = [\n        `window[${idJSON}] = window[${idJSON}] || [];`,\n        `window[${idJSON}].push(${serializedCacheArgs});`,\n      ]\n      return (\n        <script\n          key={count.current++}\n          dangerouslySetInnerHTML={{\n            __html: html.join(''),\n          }}\n        />\n      )\n    })\n    // </server stuff>\n\n    // <client stuff>\n    const onEntriesRef = React.useRef(props.onEntries)\n    React.useEffect(() => {\n      onEntriesRef.current = props.onEntries\n    })\n\n    React.useEffect(() => {\n      // Client: consume cache:\n      const onEntries = (...serializedEntries: Serialized<TShape>[]) => {\n        const entries = serializedEntries.map((serialized) =>\n          transformer.deserialize(serialized),\n        )\n        onEntriesRef.current(entries)\n      }\n\n      const win = window as any\n      // Register cache consumer\n      const winStream: Array<Serialized<TShape>> = win[id] ?? []\n\n      onEntries(...winStream)\n\n      // Register our own consumer\n      win[id] = {\n        push: onEntries,\n      }\n\n      return () => {\n        // Cleanup after unmount\n        win[id] = []\n      }\n    }, [id, transformer])\n    // </client stuff>\n\n    return (\n      <context.Provider value={{ stream, id }}>\n        {props.children}\n      </context.Provider>\n    )\n  }\n\n  return {\n    Provider: UseClientHydrationStreamProvider,\n    context,\n  }\n}\n"],"names":["push","useServerInsertedHTML","stream","key","dangerouslySetInnerHTML","__html","onEntriesRef","win","value","id","Provider","context"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAoDO;AACL;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAoBI;;AAEA;AAEA;AAGM;;;AAGF;;AAGJ;;AAEE;;AAEIA;AACE;AAAA;;AAGN;AACA;AACF;AACA;AACAC;AACE;AACAC;AAEA;AACE;AACF;AACA;AACA;;AAKA;;AAGA;;AAMIC;AACAC;AACEC;AACF;AAAE;AAGR;AACA;;AAEA;;;AAGEC;AACF;;AAGE;AACA;AACE;AAGAA;;;AAIF;AACA;;;AAIA;;AAEEN;;AAGF;AACE;AACAO;;AAEJ;AACA;;AAEA;AACoBC;;AAAiBC;AAAG;;AAI1C;;AAGEC;AACAC;;AAEJ;;"}
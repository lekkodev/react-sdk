{"version":3,"file":"ReactQueryStreamedHydration.legacy.js","sources":["../../src/ReactQueryStreamedHydration.tsx"],"sourcesContent":["'use client'\n\nimport type {\n  DehydratedState,\n  DehydrateOptions,\n  HydrateOptions,\n  QueryClient,\n} from '@tanstack/react-query'\nimport {\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate,\n  useQueryClient,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport type { HydrationStreamProviderProps } from './HydrationStreamProvider'\nimport { createHydrationStreamProvider } from './HydrationStreamProvider'\n\nconst stream = createHydrationStreamProvider<DehydratedState>()\n\n/**\n * This component is responsible for:\n * - hydrating the query client on the server\n * - dehydrating the query client on the server\n */\nexport function ReactQueryStreamedHydration(props: {\n  children: React.ReactNode\n  queryClient?: QueryClient\n  options?: {\n    hydrate?: HydrateOptions\n    dehydrate?: DehydrateOptions\n  }\n  transformer?: HydrationStreamProviderProps<DehydratedState>['transformer']\n}) {\n  const queryClient = useQueryClient(props.queryClient)\n\n  /**\n   * We need to track which queries were added/updated during the render\n   */\n  const [trackedKeys] = React.useState(() => new Set<string>())\n\n  // <server only>\n  if (typeof window === 'undefined') {\n    // Do we need to care about unsubscribing? I don't think so to be honest\n    queryClient.getQueryCache().subscribe((event) => {\n      switch (event.type) {\n        case 'added':\n        case 'updated':\n          // console.log('tracking', event.query.queryHash, 'b/c of a', event.type)\n          trackedKeys.add(event.query.queryHash)\n      }\n    })\n  }\n  // </server only>\n\n  return (\n    <stream.Provider\n      // Happens on server:\n      onFlush={() => {\n        /**\n         * Dehydrated state of the client where we only include the queries that were added/updated since the last flush\n         */\n        const shouldDehydrate =\n          props.options?.dehydrate?.shouldDehydrateQuery ??\n          defaultShouldDehydrateQuery\n\n        const dehydratedState = dehydrate(queryClient, {\n          ...props.options?.dehydrate,\n          shouldDehydrateQuery(query) {\n            return trackedKeys.has(query.queryHash) && shouldDehydrate(query)\n          },\n        })\n        trackedKeys.clear()\n\n        if (!dehydratedState.queries.length) {\n          return []\n        }\n\n        return [dehydratedState]\n      }}\n      // Happens in browser:\n      onEntries={(entries) => {\n        for (const hydratedState of entries) {\n          hydrate(queryClient, hydratedState, props.options?.hydrate)\n        }\n      }}\n      // Handle BigInts etc using superjson\n      transformer={props.transformer}\n    >\n      {props.children}\n    </stream.Provider>\n  )\n}\n"],"names":["hydrate"],"mappings":";;;;;AAkBA;;AAEA;AACA;AACA;AACA;AACA;AACO;AASL;;AAEA;AACF;AACA;AACE;;AAEA;AACA;AACE;;;AAGI;AACA;AACE;;AAEJ;AACF;AACF;AACA;;AAEA;AAEI;;AACe;AACb;AACR;AACA;;AAKQ;;;AAGI;AACF;AACF;;AAGA;AACE;AACF;;AAGF;AACA;AAAA;;AAEE;AAAqC;AACnCA;AACF;AACF;AACA;AAAA;;;AAMN;;"}
# Lekko React SDK Documentation


## Introduction

Welcome to the Lekko React SDK documentation. This SDK serves as a comprehensive toolkit for implementing feature flag and configuration management in React-based applications. Engineered to streamline the deployment and control of feature toggles, the Lekko React SDK facilitates granular type-safe feature manipulation. It enables developers to dynamically adapt application features to varied user segments, execute methodical A/B testing, and rollout configuration changes without redeploying or code updates.

## Compatibility

The Lekko React SDK is compatible with React 18.0, taking advantage of the latest features such as Suspense and concurrent rendering to provide a seamless experience. For projects using React 16.8, a legacy version of our SDK will be available in the future, ensuring backward compatibility and extended support.

### Create a Lekko Account

Before you begin, you'll need a Lekko account to access the necessary API keys and manage your configurations.

(TODO: provide steps here)
- Sign up at [Lekko Account Creation Link](#).

### Installation

Add the Lekko React SDK to your project using npm or yarn:

`@lekko/react-sdk` depends on source code generated by Buf which is hosted on their NPM registry. Prior to adding the Lekko SDK, configure your package manager to use Buf's NPM registry for `@buf` scoped packages.

> **Note**
>
> Due to the dependency on Buf's source code generation, we currently do not support installing with Yarn versions older than v2 (a.k.a. [Yarn Classic](https://yarnpkg.com/getting-started/migration)). Please refer to Buf's docs [here](https://buf.build/docs/bsr/remote-packages/npm/#other-package-managers) for more information.

#### NPM

The following command updates your `.npmrc` file.

```
npm config set @buf:registry https://buf.build/gen/npm/v1
```

#### Yarn

You must edit your [`.yarnrc.yml`](https://yarnpkg.com/configuration/yarnrc) file to include the following scope:

```yaml
npmScopes:
  buf:
    npmRegistryServer: https://buf.build/gen/npm/v1
```

Then, you can add the package to your project by running:

```bash
npm install @lekko/react-sdk
# or
yarn add @lekko/react-sdk
```

## Configuration

Properly configuring the Lekko React SDK is vital to seamlessly integrate feature flagging into your React application. The SDK can automatically retrieve configuration settings from environment variables, or you can explicitly pass a settings object if you prefer.

### Environment Variables

The Lekko SDK is designed to work with environment variables, a best practice for keeping sensitive information such as API keys and repository details secure. When using environment variables, the SDK will automatically pull these values from `process.env` if you're using `dotenv` or a similar library to manage your environment variables.

To set up your environment variables, add the following to your environment configuration file (e.g., `.env`):

```
REACT_APP_LEKKO_REPOSITORY_OWNER=your-repo-owner
REACT_APP_LEKKO_REPOSITORY_NAME=your-repo-name
REACT_APP_LEKKO_API_KEY=your-api-key
```

The SDK will use these environment variables to configure itself, so there's no need to manually pass a settings object.

### Explicit Settings Object

Alternatively, you can directly pass a settings object to the `LekkoConfigProvider` if you need to set configuration details programmatically or if environment variables are not suitable for your use case.

Here's how you can manually create a `LekkoSettings` object:

```
const lekkoSettings = {
  repositoryOwner: 'your-repo-owner',
  repositoryName: 'your-repo-name',
  apiKey: 'your-api-key',
  // Include additional settings as required
};
```
And then pass it to the `LekkoConfigProvider`:

```
import { LekkoConfigProvider } from '@lekko/react-sdk';

const App = () => {
  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoConfigProvider settings={lekkoSettings}>
        {/* Rest of your application */}
      </LekkoConfigProvider>
    </Suspense>
  );
};
```

### Initializing the LekkoConfigProvider

Whether you're using environment variables or passing a settings object directly, initializing the `LekkoConfigProvider` is the same. Add it at the root of your application to provide feature flag data throughout your component tree:

```
import { LekkoConfigProvider } from '@lekko/react-sdk';

const App = () => {
  // No need to pass settings if using environment variables
  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoConfigProvider>
        {/* Your app components go here */}
      </LekkoConfigProvider>
    </Suspense>
  );
};
```

By following this guide, you can ensure that your application is correctly connected to the Lekko system, ready to control and manage feature flags and configurations. The next section of our documentation will provide a step-by-step Quick Start guide for integrating the Lekko SDK into your application.

## Quick Start

The Quick Start guide is intended for applications where server-side rendering is not required. Ideal use cases for this guide include single-page applications (SPAs) where:

-   Server-side rendering is unnecessary.
-   The application has a Suspense boundary around components where primary context (like user information) is known, typically around the authentication layer.

If your application meets these criteria, follow these steps to quickly integrate the Lekko React SDK.

### Step 1: Configure Your Environment

Set up the necessary environment variables for your project. Add the following lines to your `.env` file:

```
REACT_APP_LEKKO_API_KEY=your-lekko-api-key
REACT_APP_LEKKO_REPOSITORY_OWNER=your-repository-owner
REACT_APP_LEKKO_REPOSITORY_NAME=your-repository-name
```

### Step 2: Initialize LekkoConfigProvider

In your root application file, import `LekkoConfigProvider` and wrap your application with it:

```
// src/App.js or src/App.tsx
import { LekkoConfigProvider } from '@lekko/react-sdk';

const lekkoSettings = {
  // Your Lekko settings retrieved from environment variables
};

const App = () => {
  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoConfigProvider settings={lekkoSettings}>
        {/* Your app's routing and layout components */}
      </LekkoConfigProvider>
    </Suspense>
  );
};
```

The top level LekkoConfigProvider can fetch configs that are known without addition context information, such as flags that are based on the environment (prod/staging/local).

```
const produductionFeatureConfig = {
    namespaceName: 'frontend',
    configName: 'production-feature',
    new Context().setString('env', /* function to retrieve current environment */),
    evaluationType: EvaluationType.BOOL,
}
<Suspense fallback={<>Loading...</>}>
  <LekkoConfigProvider configRequests={[productionFeatureConfig]}>
    {/* Your app's routing and layout components */}
  </LekkoConfigProvider>
</Suspense>
```

The `LekkoConfigProvider` only needs to be surrounded by a suspense boundary if it is fetching config evaluations.  If not, only the `LekkoIntermediateConfigProvider` needs a suspense boundary.  Other than config fetching, the primary setup functionality of the `LekkoConfigProvider` is syncrhonous.

### Step 3: Implement Authentication Handling

Create an authentication wrapper that uses `LekkoIntermediateConfigProvider` to fetch user-specific feature flags. Here's an example based on the `RequireAuth` component pattern:

```
import { Suspense, ReactNode } from 'react';
import { BrowserRouter  as  Router, Route, Routes } from  'react-router-dom';
import { LekkoIntermediateConfigProvider, ClientContext, EvaluationType } from '@lekko/react-sdk';

function Loader() {
  return <div>Loading...</div>;
}

function getFeatureFlag(user) {
  const context = new ClientContext();
  if (user.username) context.setString('username', user.username);

  return {
    namespaceName: 'frontend',
    configName: 'client-feature-flag',
    context,
    evaluationType: EvaluationType.BOOL,
  };
}

const RequireAuth = ({ children }) => {
  return (
    <Suspense fallback={<Loader />}>
      <RequireAuthInner>{children}</RequireAuthInner>
    </Suspense>
  );
};

const RequireAuthInner = ({ children }) => {
  const userLoggedInInfo = // function to fetch user login info

  return userLoggedInInfo.authenticated ? (
    <LekkoIntermediateConfigProvider configRequests={[getFeatureFlag(userLoggedInInfo)]}>
      {children}
    </LekkoIntermediateConfigProvider>
  ) : (
    // Replace with your navigation logic
    // <Navigate to="/login" />
  );
};

// Define your lekkoSettings here or import them if defined elsewhere
const lekkoSettings = {
  apiKey: process.env.REACT_APP_LEKKO_API_KEY,
  repositoryOwner: process.env.REACT_APP_LEKKO_REPOSITORY_OWNER,
  repositoryName: process.env.REACT_APP_LEKKO_REPOSITORY_NAME,
  // Other settings if necessary
};

const App = () => {
  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoConfigProvider settings={lekkoSettings}>
        <Router>
          <Suspense fallback={<Loader />}>
            <Routes>
              <Route path="/" element={<PublicComponent />} />
              <Route path="/profile" element={
                <RequireAuth>
                  <ProfileComponent />
                </RequireAuth>
              } />
              {/* Define other routes here */}
            </Routes>
          </Suspense>
        </Router>
      </LekkoConfigProvider>
    </Suspense>
  );
};

export default App;
```

### Step 4: Access Feature Flags in Components

Now you can access the evaluated feature flags within your components using the `useLekkoConfig` hook.

```
// src/components/FeatureComponent.js
import { useLekkoConfig } from '@lekko/react-sdk';

const FeatureComponent = () => {
  const featureFlag = useLekkoConfig(/* ...config */);

  return featureFlag ? <NewFeature /> : <DefaultFeature />;
};
```

**Note:** If you haven't provided the feature flag configuration with context to the `LekkoConfigProvider` or `LekkoIntermediateConfigProvider`, then you will need to ensure that `FeatureComponent` is wrapped in a Suspense boundary. This is necessary because `useLekkoConfig` may suspend while it's waiting for the feature flag evaluation to be fetched. Here's an example of how you might handle this:

```
import { Suspense } from 'react';

const FeatureComponentWithSuspense = () => {
  return (
    <Suspense fallback={<div>Loading feature...</div>}>
      <FeatureComponent />
    </Suspense>
  );
};
```

## Decision Points for Lekko SDK Integration

While the Quick Start guide provides a straightforward way to integrate the Lekko SDK into most React applications, there are scenarios where the default approach may not be suitable. Below are decision points that can help you determine the best way to use the SDK in your application.

### Non-Blocking Provider Usage

If you prefer a non-blocking rendering approach where feature flag evaluations do not delay the initial rendering of your components, you can set `nonBlockingProvider` to `true` in your `LekkoSettings`:

```
const lekkoSettings = {
  // ...other settings
  nonBlockingProvider: true,
};
```

When using this option, you will need to handle the loading and error states within your components. This approach is beneficial if you want to ensure that your application remains interactive while feature flags are being fetched.

### Using `useLekkoConfigDLE`

For applications where you have chosen not to use Suspense boundaries, the `useLekkoConfigDLE` hook allows you to handle loading and error states explicitly within your components:

```
// src/components/FeatureComponent.js
import { useLekkoConfigDLE } from '@lekko/react-sdk';

const FeatureComponent = () => {
  const { evaluation: featureFlag, isEvaluationLoading, error } = useLekkoConfigDLE({
    namespaceName: 'frontend',
    configName: 'new-dashboard-feature',
    evaluationType: 'BOOL',
  });

  if (isEvaluationLoading) return <div>Loading feature...</div>;
  if (error) return <div>Error fetching feature flag</div>;

  return featureFlag ? <NewDashboard /> : <OldDashboard />;
};
```

This hook is particularly useful for components that are not critical to the initial render and can be loaded asynchronously without compromising user experience.

### Fetching Configs on Demand with `useLekkoConfigFetch`

There might be cases where you need to fetch configurations on demand, typically in response to user actions. The `useLekkoConfigFetch` hook is designed for such scenarios:

```
import { useState } from 'react';
import { useLekkoConfigFetch, ClientContext, EvaluationType } from '@lekko/react-sdk';

function MyInputComponent() {
  const [text, setText] = useState('');

  // Fetch function provided by useLekkoConfigFetch
  const fetchConfig = useLekkoConfigFetch();

  // Handler for fetching configuration based on user input
  const handleEvaluate = async () => {
    try {
      const evaluation = await fetchConfig({
        namespaceName: 'default',
        configName: 'example',
        evaluationType: EvaluationType.BOOL,
        context: new ClientContext().setString("state", text),
      });
      
      // Process or use the fetched evaluation result here
    } catch (error) {
      // Handle errors here
    }
  };

  return (
    <div>
      <input 
        type="text" 
        value={text} 
        onChange={(e) => setText(e.target.value)} 
      />
      <button onClick={handleEvaluate}>Evaluate</button>
    </div>
  );
}
```

### Next.js Server-side rendering
(TODO)

## Error Handling

In any application, handling errors gracefully is crucial for maintaining a smooth user experience and for debugging purposes. The Lekko React SDK provides mechanisms to handle errors that may occur during feature flag evaluation or fetching. Here's how you can manage common errors in your application.

### Types of Errors

The SDK can encounter several types of errors, such as:

-   **Network Errors**: When there's an issue with the network connection, or the Lekko API is unreachable.
-   **Authorization Errors**: If the API key is incorrect or lacks the necessary permissions.
-   **Configuration Errors**: When there's an issue with the feature flag configuration, such as a non-existent flag.

### Handling Errors in `useLekkoConfigDLE`

When using `useLekkoConfigDLE`, errors are returned as part of the hook's result. You can display a message to the user or perform other error-handling logic based on the error type.

```
import { useLekkoConfigDLE, NetworkError, NotAuthorizedError, ConfigNotFoundError } from '@lekko/react-sdk';

const FeatureComponent = () => {
  const { evaluation, isEvaluationLoading, error } = useLekkoConfigDLE({
    namespaceName: 'frontend',
    configName: 'new-feature',
    evaluationType: 'BOOL',
    context: new ClientContext().setString("user_role", "admin"), // Example context
  });

  if (isEvaluationLoading) {
    return <div>Loading feature...</div>;
  }

  if (error) {
    if (error instanceof NetworkError) {
      // Handle network errors
      return <div>Cannot connect to the server. Please check your internet connection.</div>;
    } else if (error instanceof NotAuthorizedError) {
      // Handle authorization errors
      return <div>Not authorized to access this feature.</div>;
    } else if (error instanceof ConfigNotFoundError) {
      // Handle missing configuration errors
      return <div>The feature configuration was not found.</div>;
    } else {
      // Handle other types of errors
      return <div>An unexpected error occurred.</div>;
    }
  }

  return evaluation ? <NewFeature /> : <OldFeature />;
};
```

### Handling Errors in `useLekkoConfigFetch`

With `useLekkoConfigFetch`, you must handle errors using try-catch blocks within your event handlers or asynchronous functions.

```
import { useState } from 'react';
import { useLekkoConfigFetch, ClientContext, EvaluationType, NetworkError, NotAuthorizedError, ConfigNotFoundError } from '@lekko/react-sdk';

function MyInputComponent() {
  const [text, setText] = useState('');
  const fetchConfig = useLekkoConfigFetch();

  const handleEvaluate = async () => {
    try {
      const evaluation = await fetchConfig({
        namespaceName: 'default',
        configName: 'example',
        evaluationType: EvaluationType.BOOL,
        context: new ClientContext().setString("state", text),
      });
      // Use the evaluation result
    } catch (error) {
      if (error instanceof NetworkError) {
        // Handle network errors
      } else if (error instanceof NotAuthorizedError) {
        // Handle authorization errors
      } else if (error instanceof ConfigNotFoundError) {
        // Handle missing configuration errors
      } else {
        // Handle other types of errors
      }
    }
  };

  return (
    <div>
      <input 
        type="text" 
        value={text} 
        onChange={(e) => setText(e.target.value)} 
      />
      <button onClick={handleEvaluate}>Evaluate</button>
    </div>
  );
}
```

## Enhanced Error Handling in Lekko React SDK

Incorporating robust error handling mechanisms, the Lekko React SDK ensures that feature flag evaluations are resilient and reliable, even in the face of network issues or other unexpected failures.

### Automatic Retries

The SDK is designed with fault tolerance in mind, automatically attempting to retry a failed configuration fetch up to four times. This retry strategy helps mitigate transient network problems or temporary service disruptions, increasing the likelihood that feature flag evaluations will succeed without manual intervention.

Here's how automatic retries are structured within the SDK:

-   **Limitation**: After four unsuccessful attempts, the SDK will stop retrying and will handle the error according to the specified error-handling logic.

### Default Configurations as Fallbacks

To further enhance reliability, the SDK allows you to specify default configurations that serve as fallbacks. In the event of network failures where feature flag evaluations cannot be fetched from the server, the SDK will revert to these defaults, ensuring that your application can continue to operate with predefined behavior.

Here's how you can provide default configurations:

```
const defaultConfigs = [
  {
    config: {
      namespaceName: 'frontend',
      configName: 'feature-a',
      evaluationType: EvaluationType.BOOL,
    },
    result: true, // Mocked result for this feature flag
  },
  // Add more flags as necessary
];

<Suspense fallback={<>Loading...</>}>
  <LekkoConfigProvider settings={lekkoSettings} defaultConfigs={defaultConfigs}>
    {/* Application components */}
  </LekkoConfigProvider>
</Suspense>
```

In this example, `defaultConfigs` provides a list of configs with their default result values, which the SDK will use if it cannot retrieve the current evaluations due to network issues.  However, defaults will not be used if there are Authentication issues or the config specified does not exist after successfully connecting with the Lekko API.

## Caching and State Management

The Lekko React SDK leverages React Query for caching and state management to ensure optimal performance and user experience. Understanding how the SDK handles caching and state can help you make informed decisions about when and how to fetch feature flag evaluations.

### Caching Strategy

Caching is a critical feature of the Lekko SDK, which helps in minimizing network requests and improving application performance. Here's how caching works with the SDK:

-   **Stable Keys**: The SDK generates stable keys for feature flag evaluations, ensuring that repeated requests for the same flag with the same context don't trigger unnecessary network calls.
-   **Cache Configuration**: By default, the SDK caches the evaluations for the lifetime of the page session. The cache is not cleared until the page is reloaded or the user navigates away.

### Stable Keys and Context Order

The Lekko SDK utilizes stable keys to uniquely identify feature flag evaluations. A stable key is generated based on the combination of the feature flag's name and the context provided for the evaluation. This key ensures that the order of context attributes does not affect the cache, enabling consistent and reliable caching behavior.

For example, consider a feature flag evaluation with a context that includes a username and organization ID. Whether you set the username first and then the organization ID, or vice versa, the generated stable key will be the same:

```
import { ClientContext } from '@lekko/react-sdk';

// Context with username followed by organization ID
const contextA = new ClientContext()
  .setString("username", "john.doe")
  .setInt("organization_id", 42);

// Context with organization ID followed by username
const contextB = new ClientContext()
  .setInt("organization_id", 42)
  .setString("username", "john.doe");

// Despite the different order, contextA and contextB will generate the same stable key
```

### Handling State

State management within the SDK revolves around maintaining the current state of feature flag evaluations:

-   **React Query's State Management**: The state of each feature flag evaluation is managed internally by React Query. It ensures that the components have access to the most recent evaluation results.
-   **Suspense and Loading States**: When using Suspense, the component's state will be suspended while fetching the evaluation. For components using `useLekkoConfigDLE`, you'll have access to `isEvaluationLoading` to manage loading states explicitly.

### Best Practices for Caching and State Management

-   **Precaching**: Whenever possible, pre-fetch feature flag evaluations early in your application's lifecycle to fill the cache proactively.
-   **Suspense Boundaries**: Use Suspense boundaries around components that rely on feature flags to handle loading states gracefully and maintain a seamless user experience.

### Leveraging Providers for Parallel Fetching

To optimize the performance of your application, it is recommended to leverage the `LekkoConfigProvider` and `LekkoIntermediateConfigProvider` for prefetching feature flag evaluations. These providers are designed to fetch configurations in parallel, which can significantly reduce the time it takes to get the flags when they're needed.

When you wrap your application with `LekkoConfigProvider`, you have the option to pre-fetch feature flags at the application's initialization phase. This is done by passing an array of configuration requests to the provider, which will then fetch all the provided configurations in parallel and cache them for later use.

Here’s how you can proactively fill the cache with feature flag evaluations:

```
import { LekkoConfigProvider, ClientContext, EvaluationType } from '@lekko/react-sdk';

const initialFeatureFlags = [
  {
    namespaceName: 'frontend',
    configName: 'feature-a',
    evaluationType: EvaluationType.BOOL,
    context: new ClientContext().setString("region", "us-west"),
  },
  {
    namespaceName: 'frontend',
    configName: 'feature-b',
    evaluationType: EvaluationType.INT,
    context: new ClientContext().setString("user_role", "admin"),
  },
  // Add more flags as needed
];

const App = () => {
  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoConfigProvider settings={lekkoSettings} configRequests={initialFeatureFlags}>
        {/* Your application's components */}
      </LekkoConfigProvider>
    </Suspense>
  );
};
```

### Conclusion

Proactive prefetching of feature flags can substantially improve the responsiveness of your application. By utilizing the Lekko SDK's providers to fetch and cache these flags in parallel at the start, you minimize the need for on-demand fetching, which can introduce loading states and potentially degrade the user experience.

## Best Practices

Adhering to best practices while using the Lekko React SDK is key to building a robust and maintainable application. Here are some guidelines to ensure you are making the most of the SDK's capabilities:

### Prefetching Configurations

-   **Prefetch with Providers**: Utilize `LekkoConfigProvider` and `LekkoIntermediateConfigProvider` to prefetch feature flags during the initial load of your application. This practice fills the cache proactively and allows for immediate access to the flags when needed, reducing latency and avoiding unnecessary loading states.

```
// Prefetch feature flags when the application initializes
<Suspense fallback={<>Loading...</>}>
  <LekkoConfigProvider settings={lekkoSettings} configRequests={initialFeatureFlags}>
    {/* Application components */}
  </LekkoConfigProvider>
</Suspense>
```

-   **Parallel Fetching**: Fetching feature flags in parallel during the initial load of your application can significantly improve startup times and user experience. By issuing parallel network requests, you ensure that all necessary data is loaded and cached as quickly as possible.
- 
## Security Considerations

When integrating the Lekko React SDK into your application, special attention must be given to the management and use of API keys. Here's how you can handle API keys securely:

### Client-Side vs. Server-Side API Keys

The Lekko SDK ecosystem uses two types of API keys:

-   **Server-Side API Keys**: These keys are intended for use on the server only and should never be exposed to the client. They have extensive permissions and can access a wide range of API methods.  These are used in the backend SDK versions such as the go-sdk, node-server-sdk, and python-sdk.
    
-   **Client-Side API Keys**: Specifically designed for client-side use, these keys have restricted permissions. They are limited to fetching feature flag evaluations and certain metadata, which are appropriate for client-side operations.

### Best Practices for Using Client-Side API Keys

-   **Use Environment Variables**: Always store API keys in environment variables. This method keeps keys out of your version control system and your codebase, reducing the risk of accidental exposure.
    
```
# .env file
REACT_APP_LEKKO_API_KEY=your-client-side-api-key
```

-   **Load Environment Variables Securely**: Use a library like `dotenv` to load environment variables in your local development environment securely. For production, use the environment variable management system provided by your hosting provider or CI/CD pipeline.
    
-   **Limit Key Exposure**: When deploying your application, ensure that only the client-side API key is bundled with your frontend code. Server-side keys should never be included in your frontend bundle.
    
-   **Restrict Key Permissions**: Use the Lekko platform to set fine-grained permissions for your client-side API keys. Limit them to only the necessary namespaces and configurations that your frontend application requires.
    
-   **Rotate Keys Regularly**: Regularly rotate your API keys to minimize the risk of abuse if they are ever compromised. Update your environment variables and redeploy your application with the new keys.
    
-   **Monitor Usage**: Keep an eye on the usage patterns of your API keys. Unusual activity could indicate that a key has been compromised and needs to be rotated.
    
## Advanced Usage

The Lekko React SDK is versatile, catering to various advanced use cases and customization needs. Here we'll explore some of the advanced usage scenarios that can enhance your application's feature flagging capabilities.

### Custom Contexts for Dynamic Evaluations

While the SDK provides a straightforward way to evaluate feature flags based on static contexts, you might need to perform evaluations based on dynamic criteria. Here's how to create custom contexts that adapt to real-time changes within your application:

```
import { useLekkoConfig, ClientContext, EvaluationType } from '@lekko/react-sdk';

const UserProfileComponent = ({ user }) => {
  // Define a dynamic context that updates based on the user's profile changes
  const userContext = new ClientContext()
    .setString('user_role', user.role)
    .setBool('is_new_user', user.isNewUser);

  const userFeatureFlag = useLekkoConfig({
    namespaceName: 'frontend',
    configName: 'user-profile-feature',
    evaluationType: EvaluationType.BOOL,
    context: userContext,
  });

  // Render based on the user-specific feature flag
  return (
    <div>
      {userFeatureFlag ? <EnhancedUserProfile user={user} /> : <StandardUserProfile user={user} />}
    </div>
  );
};
```

### Feature Flag Layering

You might encounter scenarios where feature flags need to be layered or combined to derive a final feature state. The SDK can be used to fetch multiple flags and use a combination of their evaluations:

```
const FeatureFlagLayeringComponent = () => {
  const flagOne = useLekkoConfig({ /* ...config */ });
  const flagTwo = useLekkoConfig({ /* ...config */ });

  // Combine flags to determine the feature state
  const isFeatureActive = flagOne && flagTwo;

  return (
    <div>
      {isFeatureActive ? <NewFeature /> : <AlternateFeature />}
    </div>
  );
};
```

### Performance Optimization with Selective Flag Fetching

In large applications, it's important to optimize performance by selectively fetching flags only for the components that need them. Use the `LekkoIntermediateConfigProvider` to fetch flags for specific sections of your application:

```
const DashboardComponent = () => {
  const dashboardFlags = [
    { /* ...config for dashboard feature A */ },
    { /* ...config for dashboard feature B */ },
    // Additional dashboard-specific feature flags
  ];

  return (
    <Suspense fallback={<>Loading...</>}>
      <LekkoIntermediateConfigProvider configRequests={dashboardFlags}>
        {/* Dashboard components */}
      </LekkoIntermediateConfigProvider>
    </Suspense>
  );
};
```

## Advanced Usage: Type Safety in Feature Flag Evaluations

The Lekko React SDK's integration with TypeScript ensures that feature flag evaluations are type-safe, providing clear and predictable type outcomes for different `EvaluationType` declarations. This is how the SDK enforces the type of the evaluation result to match the specified `EvaluationType`:

-   **STRING**: The evaluation result will be of type `string`.
-   **INT**: The evaluation result will be of type `number`.
-   **FLOAT**: The evaluation result will also be of type `number`, accommodating floating-point values.
-   **BOOL**: The evaluation result will be of type `boolean`.
-   **JSON**: The evaluation result will be of type `any`, allowing for complex data structures.
-   **PROTO**: The evaluation result will be of the Protobuf `Any` type, suitable for serialized binary data.

### Matching `EvaluationType` with Configuration Definitions

Each feature flag you define in the Lekko webapp or via the CLI has a specific type associated with it. When you use the `useLekkoConfig` hook in your application, the `evaluationType` you specify must match the type you've defined in the Lekko interface.

### Generic Evaluation Result Types

Using `useLekkoConfig`, you can specify the type of evaluation you expect, and TypeScript will enforce this type for the result, ensuring that your application's feature flag logic is robust and type-safe:

```
import { useLekkoConfig, ClientContext, EvaluationType } from '@lekko/react-sdk';
import { type Any } from "@bufbuild/protobuf";

// For a boolean feature flag
const featureToggle: boolean = useLekkoConfig({
  namespaceName: 'frontend',
  configName: 'feature-toggle',
  evaluationType: EvaluationType.BOOL,
  context: new ClientContext().setString("user_role", "admin"),
});

// For a string feature flag
const featureDescription: string = useLekkoConfig({
  namespaceName: 'frontend',
  configName: 'feature-description',
  evaluationType: EvaluationType.STRING,
  context: new ClientContext().setString("user_role", "admin"),
});

// For a JSON feature flag
const featureData: any = useLekkoConfig({
  namespaceName: 'frontend',
  configName: 'feature-data',
  evaluationType: EvaluationType.JSON,
  context: new ClientContext().setString("user_role", "admin"),
});

// For a Protobuf feature flag
const featureProto: Any = useLekkoConfig({
  namespaceName: 'frontend',
  configName: 'feature-proto',
  evaluationType: EvaluationType.PROTO,
  context: new ClientContext().setString("user_role", "admin"),
});
```

### Best Practices for Type-Safe Evaluations

-   **Explicit Types**: Where possible, explicitly declare the variable type when using `useLekkoConfig`. TypeScript's type inference is powerful, but explicit types can make your intentions clearer and your code more readable.
    
-   **Avoid `any` When Possible**: While `JSON` evaluations return type `any`, use TypeScript's type assertions to narrow down to more specific types whenever you have a known structure for the JSON data.
    
-   **Protobuf Considerations**: For `PROTO` evaluations, ensure you have the necessary Protobuf type definitions at hand to work with the returned `Any` type effectively.
    
-   **Composable Hooks**: When creating custom hooks or utilities around the Lekko SDK, maintain these type safety practices to preserve the integrity of your application's type system.

## API Reference

The Lekko React SDK offers a range of APIs to manage feature flag evaluations within your React application. Below is a high-level API reference that outlines the main functions and components available. Detailed usage examples and descriptions are provided to ensure a clear understanding of how to utilize these APIs effectively.

### Hooks

#### `useLekkoConfig`

Fetches and returns the evaluation result for a given feature flag configuration.

```
function useLekkoConfig<E extends EvaluationType>(config: LekkoConfig<E>): EvaluationResult<E>;
```

-   **Parameters**:
    
    -   `config`: An object containing the `namespaceName`, `configName`, `evaluationType`, and an optional `context`.
-   **Return Type**: `EvaluationResult<E>`, where `E` is the specified `EvaluationType`.
    

#### `useLekkoConfigDLE`

Fetches the feature flag evaluation like `useLekkoConfig` but provides additional state for loading and errors.

```
function useLekkoConfigDLE<E extends EvaluationType>(config: LekkoConfig<E>): {
  evaluation: EvaluationResult<E> | undefined;
  isEvaluationLoading: boolean;
  error: Error | null;
};
```

-   **Parameters**:
    
    -   `config`: An object containing the `namespaceName`, `configName`, `evaluationType`, and an optional `context`.
-   **Return Type**: An object containing the `evaluation`, `isEvaluationLoading`, and `error`.
    

#### `useLekkoConfigFetch`

Provides a function to fetch a feature flag evaluation on demand.  Fetch will not retrieve config evaluations from the cache, nor store them in the cache after fetching.  They will retrieve up to date evaluations based on the latest rolled out version of the Lekko config.

```
function useLekkoConfigFetch<E extends EvaluationType>(): (config: LekkoConfig<E>) => Promise<EvaluationResult<E>>;
```

-   **Return Type**: A function that takes a `LekkoConfig` object and returns a `Promise` resolving to the `EvaluationResult`.

### Components

#### `LekkoConfigProvider`

Provides feature flag evaluations to your application and should wrap the root of your component hierarchy.

```
interface LekkoConfigProviderProps {
  settings: LekkoSettings;
  configRequests?: LekkoConfig<EvaluationType>[];
}

const LekkoConfigProvider: React.ComponentType<LekkoConfigProviderProps>;
```

-   **Props**:
    -   `settings`: An object containing the configuration settings for the SDK.
    -   `configRequests`: An optional array of feature flag configurations to prefetch.

#### `LekkoIntermediateConfigProvider`

A component that fetches feature flags based on a known context, such as after user authentication.

```
interface LekkoIntermediateConfigProviderProps {
  configRequests: LekkoConfig<EvaluationType>[];
}

const LekkoIntermediateConfigProvider: React.ComponentType<LekkoIntermediateConfigProviderProps>;
```

-   **Props**:
    -   `configRequests`: An array of feature flag configurations to fetch based on the provided context.

### Types and Interfaces

#### `LekkoConfig`

Defines the structure for a feature flag configuration request.

```
interface LekkoConfig<E extends EvaluationType> {
  namespaceName: string;
  configName: string;
  evaluationType: E;
  context?: ClientContext;
}
```

#### `LekkoSettings`

Specifies the settings used to initialize the Lekko client.

```
interface LekkoSettings {
  apiKey: string;
  repositoryOwner: string;
  repositoryName: string;
  hostname?: string;
  nonBlockingProvider?: boolean;
}
```

#### `EvaluationType`

An enumeration of the possible types for feature flag evaluations.

```
enum EvaluationType {
  STRING = "String",
  INT = "Int",
  FLOAT = "Float",
  BOOL = "Bool",
  JSON = "JSON",
  PROTO = "Proto",
}
```

#### `EvaluationResult`

Represents the result of a feature flag evaluation.

```
type EvaluationResult<E extends EvaluationType> = 
  E extends EvaluationType.BOOL ? boolean :
  E extends EvaluationType.FLOAT ? number :
  E extends EvaluationType.INT ? number :
  E extends EvaluationType.STRING ? string :
  E extends EvaluationType.JSON ? any :
  E extends EvaluationType.PROTO ? Any : never;
```

## Testing with Lekko React SDK

Testing is an integral part of the development process, ensuring that your feature flag implementation works as expected. The Lekko React SDK provides utilities to simplify testing components that use feature flags.

### Mocking Feature Flags

To test components that use feature flags, you can mock the responses from `useLekkoConfig` and other hooks provided by the SDK. This allows you to simulate different feature flag states during testing.

#### Jest Example with `LekkoConfigMockProvider`

Here's how you might use Jest and `@testing-library/react` to mock feature flag evaluations:

```
import { render } from '@testing-library/react';
import { LekkoConfigMockProvider, EvaluationType } from '@lekko/react-sdk';
import YourComponent from './YourComponent';

// Define the default state for the feature flags you will mock
const defaultConfigs = [
  {
    config: {
      namespaceName: 'frontend',
      configName: 'feature-a',
      evaluationType: EvaluationType.BOOL,
    },
    result: true, // Mocked result for this feature flag
  },
  // Add more flags as necessary
];

test('renders the component with the feature flag enabled', () => {
  // Wrap your component with the LekkoConfigMockProvider and pass the defaultConfigs
  const { getByText } = render(
    <LekkoConfigMockProvider defaultConfigs={defaultConfigs}>
	    <Suspense fallback={<></>}>
			<YourComponent />
		</Supsense>
    </LekkoConfigMockProvider>
  );

  // Assertions will depend on how YourComponent uses the feature flag
  expect(getByText('Feature A is enabled')).toBeInTheDocument();
});
```

In this example, `defaultConfigs` provides the mocked evaluation result for `feature-a`, allowing you to test `YourComponent` as if the feature flag is enabled.

### Integration Tests

For integration tests where you want to test the interaction between components and the feature flag evaluations, you can use the same mocking strategy but at a broader scope. Wrap the top-level component of your test with `LekkoConfigMockProvider` to provide consistent mock data for all child components.

### Testing Hooks

If you have custom hooks that use feature flags, you can also test these hooks directly using the `react-hooks/testing-library`:

```
import { renderHook } from '@testing-library/react-hooks';
import { useMyCustomHook } from './useMyCustomHook';
import { LekkoConfigMockProvider } from '@lekko/react-sdk';

test('useMyCustomHook returns the correct data based on feature flags', () => {
  const wrapper = ({ children }) => (
    <LekkoConfigMockProvider defaultConfigs={/* mocked feature flags */}>
	    <Suspense fallback={<></>}
	      {children}
	    </Supsense>
    </LekkoConfigMockProvider>
  );

  const { result } = renderHook(() => useMyCustomHook(), { wrapper });

  // Assertions for your custom hook's return values
});
```

### Best Practices for Testing

-   **Isolate Feature Flags**: When writing unit tests, isolate the effects of feature flags as much as possible to test components in different states.
-   **Test All Flag States**: Ensure you test all possible states of a feature flag to cover the different branches of logic in your components.